// NTSleuth - Advanced Windows syscall extraction & analysis framework
// Copyright (c) 2025 Alexander Hagenah (@xaitax)
// Licensed under the BSD 3-Clause License - see LICENSE file for details

#include "output/c_header_formatter.h"
#include "utils/logger.h"
#include <fstream>
#include <sstream>
#include <algorithm>
#include <cctype>

namespace WinSyscall
{

    CHeaderFormatter::CHeaderFormatter()
    {
    }

    bool CHeaderFormatter::Format(const ExtractionResult &result, std::ostream &output)
    {
        try
        {
            WriteHeader(output, result);
            WriteIncludes(output);

            if (generate_defines_)
            {
                WriteDefines(output, result.syscalls);
            }

            if (generate_enums_)
            {
                WriteEnums(output, result.syscalls);
            }

            if (generate_typedefs_)
            {
                WriteTypedefs(output, result.syscalls);
            }

            WriteFooter(output);

            return true;
        }
        catch (const std::exception &e)
        {
            LOG_ERROR("Failed to format C header: " + std::string(e.what()));
            return false;
        }
    }

    bool CHeaderFormatter::SaveToFile(const ExtractionResult &result, const std::string &path)
    {
        try
        {
            std::ofstream file(path);
            if (!file.is_open())
            {
                LOG_ERROR("Failed to open file: " + path);
                return false;
            }

            bool success = Format(result, file);
            file.close();

            return success;
        }
        catch (const std::exception &e)
        {
            LOG_ERROR("Failed to save C header file: " + std::string(e.what()));
            return false;
        }
    }

    void CHeaderFormatter::WriteHeader(std::ostream &out, const ExtractionResult &result)
    {
        out << "/*\n";
        out << " * Windows Syscall Definitions\n";
        out << " * Generated by NTSleuth - Windows Syscall Extractor\n";
        out << " * https://github.com/xaitax/NTSleuth\n";
        out << " * \n";
        out << " * OS Version: " << result.os_info.version_string << "\n";
        out << " * Architecture: ";

        switch (result.os_info.architecture)
        {
        case Architecture::x64:
            out << "x64 (AMD64)";
            break;
        case Architecture::ARM64:
            out << "ARM64";
            break;
        case Architecture::x86:
            out << "x86 (i386)";
            break;
        default:
            out << "Unknown";
            break;
        }

        out << "\n";
        out << " * Build: " << result.os_info.build_number;
        if (result.os_info.revision > 0)
        {
            out << "." << result.os_info.revision;
        }
        out << "\n";
        out << " * Total Syscalls: " << result.syscalls.size() << "\n";

        // Count true syscalls
        int true_syscalls = 0;
        for (const auto &syscall : result.syscalls)
        {
            if (syscall.is_true_syscall && syscall.alias_of.empty())
            {
                true_syscalls++;
            }
        }
        out << " * True Syscalls: " << true_syscalls << "\n";
        out << " * \n";
        out << " * Usage:\n";
        out << " *   1. Include this header in your project\n";
        out << " *   2. Use function typedefs to dynamically resolve syscalls\n";
        out << " *   3. Use syscall numbers for direct syscall invocation\n";
        out << " */\n\n";

        out << "#pragma once\n\n";
        out << "#ifndef _WINDOWS_SYSCALLS_H_\n";
        out << "#define _WINDOWS_SYSCALLS_H_\n\n";

        out << "#ifdef __cplusplus\n";
        out << "extern \"C\" {\n";
        out << "#endif\n\n";
    }

    void CHeaderFormatter::WriteIncludes(std::ostream &out)
    {
        out << "/* Required Windows headers */\n";
        out << "#include <Windows.h>\n";
        out << "#include <winternl.h>\n\n";

        out << "/* Disable SAL warnings if not using SAL */\n";
        out << "#ifndef _USE_SAL_ANNOTATIONS\n";
        out << "#pragma warning(push)\n";
        out << "#pragma warning(disable: 28251) // Inconsistent SAL annotations\n";
        out << "#endif\n\n";

        out << "/* Calling convention macros */\n";
        out << "#ifndef NTAPI\n";
        out << "#define NTAPI __stdcall\n";
        out << "#endif\n\n";

        out << "#ifndef WINAPI\n";
        out << "#define WINAPI __stdcall\n";
        out << "#endif\n\n";

        out << "/* Helper macros for syscall invocation */\n";
        out << "#define SYSCALL_INVOKE(number) __asm { mov eax, number; }\n\n";
    }

    void CHeaderFormatter::WriteDefines(std::ostream &out, const std::vector<Syscall> &syscalls)
    {
        out << "// Syscall Numbers\n";
        out << "// Usage: mov eax, SYSCALL_NUMBER_NtCreateFile\n\n";

        std::string current_module;

        for (const auto &syscall : syscalls)
        {
            // Skip non-syscalls
            if (!syscall.is_true_syscall)
            {
                continue;
            }

            // Skip aliases
            if (!syscall.alias_of.empty())
            {
                continue;
            }

            // Add module separator
            if (syscall.module_name != current_module)
            {
                if (!current_module.empty())
                {
                    out << "\n";
                }
                out << "// " << syscall.module_name << "\n";
                current_module = syscall.module_name;
            }

            std::string define_name = prefix_ + "NUMBER_" + syscall.name;
            std::transform(define_name.begin(), define_name.end(), define_name.begin(),
                           [](unsigned char c)
                           { return static_cast<char>(::toupper(c)); });

            out << "#define " << define_name << " 0x"
                << std::hex << std::uppercase << syscall.syscall_number
                << std::dec << "\n";
        }

        out << "\n";
    }

    void CHeaderFormatter::WriteEnums(std::ostream &out, const std::vector<Syscall> &syscalls)
    {
        out << "// Syscall Number Enumeration\n";
        out << "typedef enum _SYSCALL_NUMBER {\n";

        bool first = true;
        for (const auto &syscall : syscalls)
        {
            if (!syscall.is_true_syscall || !syscall.alias_of.empty())
            {
                continue;
            }

            if (!first)
            {
                out << ",\n";
            }
            first = false;

            std::string enum_name = "SyscallNumber_" + syscall.name;
            out << "    " << enum_name << " = 0x"
                << std::hex << std::uppercase << syscall.syscall_number << std::dec;
        }

        out << "\n} SYSCALL_NUMBER;\n\n";
    }

    void CHeaderFormatter::WriteTypedefs(std::ostream &out, const std::vector<Syscall> &syscalls)
    {
        out << "/*\n";
        out << " * Function Prototypes\n";
        out << " * \n";
        out << " * Usage example:\n";
        out << " *   HMODULE ntdll = GetModuleHandle(L\"ntdll.dll\");\n";
        out << " *   pfnNtCreateFile pNtCreateFile = (pfnNtCreateFile)GetProcAddress(ntdll, \"NtCreateFile\");\n";
        out << " *   if (pNtCreateFile) {\n";
        out << " *       NTSTATUS status = pNtCreateFile(...);\n";
        out << " *   }\n";
        out << " */\n\n";

        std::string current_module;
        int typedef_count = 0;

        for (const auto &syscall : syscalls)
        {
            // Skip aliases
            if (!syscall.alias_of.empty())
            {
                continue;
            }

            // Add module separator with count
            if (syscall.module_name != current_module)
            {
                if (!current_module.empty())
                {
                    out << "/* End of " << current_module << " - " << typedef_count << " functions */\n\n";
                    typedef_count = 0;
                }
                out << "/* ===== " << syscall.module_name << " ===== */\n";
                current_module = syscall.module_name;
            }

            // Add inline documentation for important syscalls
            if (syscall.is_true_syscall)
            {
                out << "/* Syscall #0x" << std::hex << std::uppercase
                    << syscall.syscall_number << std::dec << " */\n";
            }

            std::string typedef_str = FormatTypedef(syscall);

            // Check if we've already generated this typedef (for overloaded functions)
            if (generated_typedefs_.find(typedef_str) == generated_typedefs_.end())
            {
                out << typedef_str << "\n\n";
                generated_typedefs_.insert(typedef_str);
                typedef_count++;
            }
        }

        if (!current_module.empty())
        {
            out << "/* End of " << current_module << " - " << typedef_count << " functions */\n";
        }

        out << "\n";
    }

    void CHeaderFormatter::WriteFooter(std::ostream &out)
    {
        out << "\n/* Restore warning state */\n";
        out << "#ifndef _USE_SAL_ANNOTATIONS\n";
        out << "#pragma warning(pop)\n";
        out << "#endif\n\n";

        out << "#ifdef __cplusplus\n";
        out << "}\n";
        out << "#endif\n\n";

        out << "#endif // _WINDOWS_SYSCALLS_H_\n";
    }

    std::string CHeaderFormatter::FormatTypedef(const Syscall &syscall)
    {
        std::stringstream ss;

        ss << "typedef ";

        // Return type
        if (syscall.return_type.empty())
        {
            ss << "NTSTATUS";
        }
        else
        {
            ss << syscall.return_type;
        }

        // Calling convention
        ss << " (" << GetCallingConventionMacro(syscall.calling_convention) << " *pfn" << syscall.name << ")(";

        // Parameters
        if (syscall.parameters.empty())
        {
            ss << "VOID";
        }
        else
        {
            ss << "\n    " << FormatParameters(syscall.parameters) << "\n";
        }

        ss << ");";

        return ss.str();
    }

    std::string CHeaderFormatter::FormatParameters(const std::vector<Parameter> &params)
    {
        std::stringstream ss;

        for (size_t i = 0; i < params.size(); ++i)
        {
            if (i > 0)
            {
                ss << ",\n    ";
            }

            ss << FormatParameterType(params[i]);

            if (!params[i].name.empty())
            {
                ss << " " << MakeValidIdentifier(params[i].name);
            }
            else
            {
                ss << " param" << i;
            }
        }

        return ss.str();
    }

    std::string CHeaderFormatter::FormatParameterType(const Parameter &param)
    {
        std::string type = param.type;

        // Remove SAL annotations and clean up the type
        // Common SAL annotations to remove
        static const std::vector<std::string> sal_annotations = {
            "_In_", "_Out_", "_Inout_", "_In_opt_", "_Out_opt_", "_Inout_opt_",
            "_In_z_", "_Out_z_", "_Inout_z_", "_In_reads_", "_Out_writes_",
            "_In_reads_bytes_", "_Out_writes_bytes_", "_Inout_updates_",
            "_In_reads_opt_", "_Out_writes_opt_", "_Inout_updates_bytes_",
            "_Reserved_", "_Check_return_", "_Must_inspect_result_",
            "_Pre_", "_Post_", "_Ret_", "_Deref_", "_Notref_",
            "_Pre_valid_", "_Post_valid_", "_Pre_z_", "_Post_z_",
            "_Pre_null_", "_Post_null_", "_Pre_maybenull_", "_Post_maybenull_",
            "_Pre_notnull_", "_Post_notnull_", "_Null_terminated_",
            "_NullNull_terminated_", "_Field_size_", "_Field_size_bytes_",
            "_Field_size_opt_", "_Field_size_bytes_opt_", "_Field_z_",
            "_Struct_size_bytes_", "_In_range_", "_Out_range_",
            "_Satisfies_", "_Pre_satisfies_", "_Post_satisfies_",
            "_Points_to_data_", "_Readable_bytes_", "_Readable_elements_",
            "_Writable_bytes_", "_Writable_elements_", "_Null_",
            "_Notnull_", "_Maybenull_", "_Maybevalid_", "_Valid_",
            "_Notvalid_", "_Success_", "_On_failure_", "_Always_",
            "_Use_decl_annotations_", "_Pre_defensive_", "_Post_defensive_",
            "_Pre_unknown_", "_Post_unknown_", "_Pre_cap_", "_Post_cap_",
            "_At_", "_When_", "_Analysis_assume_", "_Analysis_mode_",
            "_Analysis_noreturn_", "_Analysis_suppress_", "_Acquires_lock_",
            "_Releases_lock_", "_Requires_lock_held_", "_Requires_lock_not_held_",
            "_Requires_no_locks_held_", "_Guarded_by_", "_Interlocked_",
            "_Post_same_lock_", "_Benign_race_begin_", "_Benign_race_end_",
            "_No_competing_thread_", "_Kernel_entry_", "_Kernel_float_used_",
            "_Kernel_float_saved_", "_Kernel_float_restored_", "_Function_class_",
            "writes_bytes_", "reads_bytes_", "writes_to_", "reads_from_"};

        // Remove SAL annotations
        for (const auto &annotation : sal_annotations)
        {
            size_t pos = 0;
            while ((pos = type.find(annotation)) != std::string::npos)
            {
                // Find the end of the annotation (could have parameters in parentheses)
                size_t end_pos = pos + annotation.length();
                if (end_pos < type.length() && type[end_pos] == '(')
                {
                    // Find matching closing parenthesis
                    int paren_count = 1;
                    end_pos++;
                    while (end_pos < type.length() && paren_count > 0)
                    {
                        if (type[end_pos] == '(')
                            paren_count++;
                        else if (type[end_pos] == ')')
                            paren_count--;
                        end_pos++;
                    }
                }
                type.erase(pos, end_pos - pos);
            }
        }

        // Clean up extra spaces
        size_t pos = 0;
        while ((pos = type.find("  ")) != std::string::npos)
        {
            type.replace(pos, 2, " ");
        }

        // Trim leading/trailing spaces
        type.erase(0, type.find_first_not_of(" \t"));
        type.erase(type.find_last_not_of(" \t") + 1);

        // Add const prefix if needed
        if (param.is_const && type.find("CONST") == std::string::npos)
        {
            type = "CONST " + type;
        }

        // Ensure pointer is properly formatted
        if (param.is_pointer && type.find('*') == std::string::npos)
        {
            type += "*";
        }

        // Handle special cases
        if (type.empty() || type == "param" || type.find("param") == 0)
        {
            // Default to PVOID for unknown types
            type = "PVOID";
        }

        return type;
    }

    std::string CHeaderFormatter::MakeValidIdentifier(const std::string &name)
    {
        std::string result = name;

        // Replace invalid characters
        for (char &c : result)
        {
            if (!std::isalnum(c) && c != '_')
            {
                c = '_';
            }
        }

        // Ensure it doesn't start with a digit
        if (!result.empty() && std::isdigit(result[0]))
        {
            result = "_" + result;
        }

        // Check for reserved keywords
        static const std::set<std::string> reserved_keywords = {
            "auto", "break", "case", "char", "const", "continue", "default", "do",
            "double", "else", "enum", "extern", "float", "for", "goto", "if",
            "int", "long", "register", "return", "short", "signed", "sizeof", "static",
            "struct", "switch", "typedef", "union", "unsigned", "void", "volatile", "while"};

        if (reserved_keywords.find(result) != reserved_keywords.end())
        {
            result += "_";
        }

        return result;
    }

    std::string CHeaderFormatter::GetCallingConventionMacro(CallingConvention cc)
    {
        switch (cc)
        {
        case CallingConvention::Stdcall:
            return "NTAPI";
        case CallingConvention::Fastcall:
            return "__fastcall";
        case CallingConvention::Cdecl:
            return "__cdecl";
        case CallingConvention::Thiscall:
            return "__thiscall";
        default:
            return "WINAPI";
        }
    }

}
